<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="description" content="Introduction to the Stockham FFT">
<meta name="keywords" content="Stockham algorithm,FFT,C++">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="otfft-en.css" type="text/css">
<link rel="next" href="stockham2.html">

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript" src="ga.js"></script>

<title>Introduction to the Stockham FFT</title>
</head>
<body>
<b>Reference:</b>&nbsp;
<a href="stockham2.html">Next Page</a>&nbsp;&nbsp;
<a href="index.html">OTFFT -- The FFT library that is faster than FFTW</a>&nbsp;&nbsp;
<a href="http://www.moon.sannet.ne.jp/okahisa/stockham/node1.html">Japanese Page</a>
<hr>
<h3>Table of contents</h3>
<ol>
    <li><a href="#stockham-intro">Introduction to the Stockham FFT</a></li>
    <li><a href="stockham2.html">Iterative version of the Stockham FFT</a></li>
    <li><a href="stockham3.html">Kinds of Stockham Algorithms</a></li>
    <li><a href="stockham4.html">Radix-4 Stockham FFT</a></li>
    <li><a href="stockham5.html">Optimization that reduce the accesses to an array</a></li>
    <li><a href="stockham6.html">Optimization by AVX of the Stockham FFT</a></li>
    <li><a href="stockham7.html">Optimization using the Six-Step FFT and Eight-Step FFT</a></li>
</ol>
<hr>
<h1><a name="stockham-intro"></a>
Introduction to the Stockham FFT
</h1>
<p>
This page is a homepage explaining the Stockham algorithm which is a kind of
the Fast Fourier Transform (FFT). I made this homepage for people who can not
understand the Stockham algorithm but can understand the Cooley-Tukey algorithm.
You will be able to understand that Stockham algorithm is a transformation of
Cooley-Tukey algorithm if you read this page.
</p>
<p>
First of all, I show the Cooley-Tukey algorithm.
When I implement the Cooley-Tukey algorithm using recursive-call,
the program will be as follows.
</p>
<a name="list:cooley-tukey"></a>
<div style="text-align:center;max-width:1000px">
List-1: Cooley-Tukey Algorithm
</div>
<pre style="border:1px solid gray;padding:4px;max-width:1000px;overflow:auto">
#include &lt;complex&gt;
#include &lt;cmath&gt;
#include &lt;utility&gt;

typedef std::complex&lt;double&gt; complex_t;

void butterfly(int n, int q, complex_t* x) // Butterfly operation
// n : sequence length
// q : block start point
// x : input/output squence
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n &gt; 1) {
        for (int p = 0; p &lt; m; p++) {
            const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
            const complex_t a = x[q + p + 0];
            const complex_t b = x[q + p + m];
            x[q + p + 0] =  a + b;
            x[q + p + m] = (a - b) * wp;
        }
        butterfly(n/2, q + 0, x);
        butterfly(n/2, q + m, x);
    }
}

void bit_reverse(int n, complex_t* x) // Bitreversal operation
// n : squence length
// x : input/output sequence
{
    for (int i = 0, j = 1; j &lt; n-1; j++) {
        for (int k = n &gt;&gt; 1; k &gt; (i ^= k); k &gt;&gt;= 1);
        if (i &lt; j) std::swap(x[i], x[j]);
    }
}

void fft(int n, complex_t* x) // Fourier transform
// n : sequence length
// x : input/output sequence
{
    butterfly(n, 0, x);
    bit_reverse(n, x);
    for (int k = 0; k &lt; n; k++) x[k] /= n;
}

void ifft(int n, complex_t* x) // Inverse Fourier transform
// n : sequence length
// x : input/output sequence
{
    for (int p = 0; p &lt; n; p++) x[p] = conj(x[p]);
    butterfly(n, 0, x);
    bit_reverse(n, x);
    for (int k = 0; k &lt; n; k++) x[k] = conj(x[k]);
}
</pre>
<p>
The characteristic of Cooley-Tukey algorithm is <code>bit_reverse()</code>.
We need <code>bit_reverse()</code> to sort the result of FFT in a natural
order. This is an important point that is different from the Stockham algorithm.
In the Stockham algorithm, even if there is no <code>bit_reverse()</code>,
the result of FFT is sorted in a natural order.
</p>
<p>
However, it is possible by the Cooley-Tukey algorithm even if we do not use
<code>bit_reverse()</code> if we only want to sort the result of FFT in a
natural order.
The result of FFT becomes a natural order sequence if we do as follows.
</p>
<a name="list:cooley-tukey2"></a>
<div style="text-align:center;max-width:1000px">
List-2: Natural Order Cooley-Tukey Algorithm
</div>
<pre style="border:1px solid gray;padding:4px;max-width:1000px;overflow:auto">
#include &lt;complex&gt;
#include &lt;cmath&gt;

typedef std::complex&lt;double&gt; complex_t;

void fft0(int n, int q, complex_t* x, complex_t* y)
// n : sequence length
// q : block start point
// x : input/output sequence
// y : work area
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n &gt; 1) {
        for (int p = 0; p &lt; m; p++) { // Butterfly operation
            const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
            const complex_t a = x[q + p + 0];
            const complex_t b = x[q + p + m];
            y[q + p + 0] =  a + b;
            y[q + p + m] = (a - b) * wp;
        }
        fft0(n/2, q + 0, y, x);
        fft0(n/2, q + m, y, x);
        for (int p = 0; p &lt; m; p++) { // Composition of even components and odd components
            x[q + 2*p + 0] = y[q + p + 0]; // Even components
            x[q + 2*p + 1] = y[q + p + m]; // Odd components
        }
    }
}

void fft(int n, complex_t* x) // Fourier transform
// n : sequence length
// x : input/output sequence
{
    complex_t* y = new complex_t[n]; // Allocation of work arera
    fft0(n, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] /= n;
}

void ifft(int n, complex_t* x) // Inverse Fourier transform
// n : sequence length
// x : input/output sequence
{
    for (int p = 0; p &lt; n; p++) x[p] = conj(x[p]);
    complex_t* y = new complex_t[n]; // Allocation of work area
    fft0(n, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] = conj(x[k]);
}
</pre>
<p>
When we assume that \(F_N\) is
Fourier transform (the size is \(N, N = 2^L, L \ge 0, L\) is an integer)
and assume that \(x_p~(p = 0,1,\ldots,N-1)\) is input sequence
and assume that \(X_k~(k = 0,1,\ldots,N-1)\) is output sequence,
Fourier transform is represented as
\(X_k = F_N(x_p) = \frac{1}{N}\sum_{p=0}^{N-1}x_p W_N^{kp},~
W_N = \exp\left(-j\frac{2\pi}{N}\right),~j = \sqrt{-1}\).
Now, if we assume \(N \ge 2\) and we decompose \(F_N\) by a recursion,
the following relationship is satisfied.
</p>
<div style="font-size:141%;">
\[
\begin{eqnarray*}
    2X_{2k}   & = & F_{\frac{N}{2}}(x_p + x_{p+\frac{N}{2}}) \\
    2X_{2k+1} & = & F_{\frac{N}{2}}\left((x_p - x_{p+\frac{N}{2}}) W_N^p\right) \\
    p         & = & 0,1,\ldots,\frac{N}{2}-1 \\
    k         & = & 0,1,\ldots,\frac{N}{2}-1 \\
\end{eqnarray*}
\]
</div>
<p>
In this way, if we decompose Fourier transform by a recursion,
even components(\(X_{2k}\)) and odd components(\(X_{2k+1}\)) are obtained.
Therefore, in order to change the output to a natural order sequence,
we have to obtain \(X_k\) by composing \(X_{2k}\) and \(X_{2k+1}\).
The code performing it is the List-2. However, this code is slow.
So, it is a turn of the Stockham algorithm.
</p>
<p>
In order to obtain the Stockham algorithm, let's start by eliminating
the uselessness from the List-2.
First, we notice that we are accessing to the array at two places.
One is at the butterfly operation.
Another is the place that we are composing even components and odd components.
We can avoid uselessness if we execute butterfly operation and
composition of even components and odd components at the same time.
Using this idea, if we transform the List-2, it will be as follows.
</p>
<a name="list:selfsort1"></a>
<div style="text-align:center;max-width:1000px">
List-3: Recursive version of the Stockham Algorithm
</div>
<pre style="border:1px solid gray;padding:4px;max-width:1000px;overflow:auto">
#include &lt;complex&gt;
#include &lt;cmath&gt;

typedef std::complex&lt;double&gt; complex_t;

void fft1(int n, int s, int q, complex_t* x, complex_t* y);

void fft0(int n, int s, int q, complex_t* x, complex_t* y)
// n : sequence length
// s : stride
// q : selection of even or odd
// x : input/output sequence
// y : work area
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n == 1) {}
    else {
        for (int p = 0; p &lt; m; p++) {
            // Butterfly operation and composition of even components and odd components
            const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
            const complex_t a = x[q + s*(p + 0)];
            const complex_t b = x[q + s*(p + m)];
            y[q + s*(2*p + 0)] =  a + b;
            y[q + s*(2*p + 1)] = (a - b) * wp;
        }
        fft1(n/2, 2*s, q + 0, y, x); // Even place FFT (y:input, x:output)
        fft1(n/2, 2*s, q + s, y, x); // Odd place FFT (y:input, x:output)
    }
}

void fft1(int n, int s, int q, complex_t* x, complex_t* y)
// n : sequence length
// s : stride
// q : selection of even or odd
// x : input sequence
// y : output sequence
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n == 1) { y[q] = x[q]; }
    else {
        for (int p = 0; p &lt; m; p++) {
            // Butterfly Operation and composition of even components and odd components
            const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
            const complex_t a = x[q + s*(p + 0)];
            const complex_t b = x[q + s*(p + m)];
            y[q + s*(2*p + 0)] =  a + b;
            y[q + s*(2*p + 1)] = (a - b) * wp;
        }
        fft0(n/2, 2*s, q + 0, y, x); // Even place FFT (y:input/output, x:work area)
        fft0(n/2, 2*s, q + s, y, x); // Odd place FFT (y:input/output, x:work area)
    }
}

void fft(int n, complex_t* x) // Fourier transform
// n : sequence length
// x : input/output sequence
{
    complex_t* y = new complex_t[n]; // Allocation of work area
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] /= n;
}

void ifft(int n, complex_t* x) // Inverse Fourier transform
// n : sequence length
// x : input/output sequence
{
    for (int p = 0; p &lt; n; p++) x[p] = conj(x[p]);
    complex_t* y = new complex_t[n]; // Allocation of work area
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] = conj(x[k]);
}
</pre>
<p>
This code has become a mutual recursion
in order to minimize the accesses to an array.
Stockham algorithm requires work area <code>y</code> for sorting.
It saves sorted results once in the work area.
If the saved results are written back immediately to <code>x</code>,
the program is able to avoid becoming a mutual recursion.
But, if we do so, it becomes meaningless
that we have reduced the accesses to an array
by executing butterfly operation and composition at the same time.
For this reason, this code has become a mutual recursion.
</p>
<p>
I will explain about <code>fft0()</code> and <code>fft1()</code>.
</p>
<p>
<code>fft0()</code> is the Fourier transform that the size is <code>n</code>.
<code>s</code> is the stride of array access.
<code>q</code> is used for selection of even or odd.
<code>x</code> is input/output sequence and <code>y</code> is work area.
</p>
<p>
<code>fft1()</code> is the Fourier transform that the size is <code>n</code>.
<code>s</code> is the stride of array access.
<code>q</code> is used for selection of even or odd.
<code>x</code> is input sequence and <code>y</code> is output sequence.
</p>
<p>
By the way, were you able to understand this transformation?
In fact, this code is the Stockham algorithm.
This is very rare recursive version of the Stockham algorithm.
So, let's transform the calculation into a recurrence formula
with this condition: \(m = 2^{L-h-1},~s = 2^h,~x_h(q,p) = x_h[q+sp]\).
</p>
<div style="font-size:141%;">
\[
\begin{eqnarray*}
    x_{h+1}(q,p)     & = & x_h(q,p) + x_h(q,p + m) \\
    x_{h+1}(q + s,p) & = & \left(x_h(q,p) - x_h(q,p + m)\right)W_N^{sp} \\
    q                & = & 0,1,\ldots,s-1 \\
    p                & = & 0,1,\ldots,m-1 \\
\end{eqnarray*}
\]
</div>
<p>
\(x_h[~]\) is array of the \(h\)-step calculation.
When we begin from \(x_0[~]\) and get \(x_L[~]\), we complete the FFT.
However, \(x_L[~]\) needs to be divided by \(N\).
</p>
<p>
This program is called Dacimation In Frequency (DIF).
In the case of Decimation In Time (DIT), the program will be as follows.
</p>
<a name="list:selfsort-dit1"></a>
<div style="text-align:center;max-width:1000px">
List-4: DIT Stockham Algorithm
</div>
<pre style="border:1px solid gray;padding:4px;max-width:1000px;overflow:auto">
#include &lt;complex&gt;
#include &lt;cmath&gt;

typedef std::complex&lt;double&gt; complex_t;

void fft1(int n, int s, int q, complex_t* x, complex_t* y);

void fft0(int n, int s, int q, complex_t* x, complex_t* y)
// n : sequence length
// s : stride
// q : selection of even or odd
// x : input/output sequence
// y : work area
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n == 1) {}
    else {
        fft1(n/2, 2*s, q + 0, y, x); // Even place FFT(x:input, y:output)
        fft1(n/2, 2*s, q + s, y, x); // Odd place FFT(x:input, y:output)
        for (int p = 0; p &lt; m; p++) {
            const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
            const complex_t a = y[q + s*(2*p + 0)];
            const complex_t b = y[q + s*(2*p + 1)] * wp;
            x[q + s*(p + 0)] = a + b;
            x[q + s*(p + m)] = a - b;
        }
    }
}

void fft1(int n, int s, int q, complex_t* x, complex_t* y)
// n : sequence length
// s : stride
// q : selection of even or odd
// x : output sequence
// y : input sequence
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n == 1) { x[q] = y[q]; }
    else {
        fft0(n/2, 2*s, q + 0, y, x); // Even place FFT(y:input/output, x:work area)
        fft0(n/2, 2*s, q + s, y, x); // Odd place FFT(y:input/output, x:work area)
        for (int p = 0; p &lt; m; p++) {
            const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
            const complex_t a = y[q + s*(2*p + 0)];
            const complex_t b = y[q + s*(2*p + 1)] * wp;
            x[q + s*(p + 0)] = a + b;
            x[q + s*(p + m)] = a - b;
        }
    }
}

void fft(int n, complex_t* x) // Fourier transform
// n : sequence length
// x : input/output sequence
{
    complex_t* y = new complex_t[n]; // Allocation of work area
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] /= n;
}

void ifft(int n, complex_t* x) // Inverse Fourier transform
// n : sequence length
// x : input/output sequence
{
    for (int p = 0; p &lt; n; p++) x[p] = conj(x[p]);
    complex_t* y = new complex_t[n]; // Allocation of work area
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] = conj(x[k]);
}
</pre>
<p>
Let's transform the calculation into a recurrence formula with this condition:
\(m = 2^h,~s = 2^{L-h-1},~x_h(q,p) = x_h[q+2sp]\).
</p>
<div style="font-size:141%;">
\[
\begin{eqnarray*}
    x_{h+1}(q,p)     & = & x_h(q,p) + x_h(q + s,p)W_N^{sp} \\
    x_{h+1}(q,p + m) & = & x_h(q,p) - x_h(q + s,p)W_N^{sp} \\
    q                & = & 0,1,\ldots,s-1 \\
    p                & = & 0,1,\ldots,m-1 \\
\end{eqnarray*}
\]
</div>
<p>
Unfortunately, this recursive version of the Stockham FFT is slow.
So, we will lead the high-speed iterative version of the Stockham FFT
in <a href="stockham2.html">the next page</a>.
</p>

<hr>
<b>Reference:</b>&nbsp;
<a href="stockham2.html">Next Page</a>&nbsp;&nbsp;
<a href="index.html">OTFFT -- The FFT library that is faster than FFTW</a>&nbsp;&nbsp;
<a href="http://www.moon.sannet.ne.jp/okahisa/stockham/node1.html">Japanese Page</a>
</body>
</html>
