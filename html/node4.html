<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="description" CONTENT="4 FFTW より速い FFT ライブラリ OTFFT">
<META NAME="keywords" CONTENT="stockham fft,ベンチマーク,benchmark">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<LINK REL="STYLESHEET" HREF="stockham.css" TYPE="text/css">
<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="stockham.html">
<LINK REL="next" HREF="node5.html">

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript" src="ga.js"></script>

<TITLE>4 FFTW より速い FFT ライブラリ OTFFT</TITLE>
</HEAD>
<BODY>
<A NAME="tex2html51"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html49"
  HREF="stockham.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html43"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A>   <BR>
<B> Next:</B> <A NAME="tex2html52"
  HREF="node5.html">5 OTFFT の使い方</A>
<B>Up:</B> <A NAME="tex2html50"
  HREF="stockham.html">stockham</A>
<B> Previous:</B> <A NAME="tex2html44"
  HREF="node3.html">3 4基底の Stockham FFT</A>
<B> Reference:</B> <A HREF="shibafft.html">ShibaFFT -- Fortran90 で書かれた混合基数 FFT ライブラリ</A>
<BR>
<H1><A NAME="SECTION00040000000000000000"></A><A NAME="otfft"></A>
4 FFTW より速い FFT ライブラリ OTFFT
</H1>
<P>
　<A HREF="node1.html">セクション1</A>, <A HREF="node2.html">セクション2</A>,
<A HREF="node3.html">セクション3</A>で、
　せっかく高速な Stockham FFT アルゴリズムを導いたのですから、
実際にそれを使ったらどうなるか試してみたいですよね。
そこで、Stockham のアルゴリズムを用いた FFT ライブラリを作ってみました。
その名も OTFFT です(OK おじさん Template FFT の略)。
実はこっそり Sixstep FFT アルゴリズムも使ってます。
Sixstep FFT に関しては適当にググってみてください。
その他、アルゴリズムではありませんが、
C++ の template によるメタプログラミング技法を駆使し、
さらに、SSE2/AVX/AVX2 イントリンシックを用いて実装してあります。
ですから、Intel アーキテクチャ CPU 専用ライブラリです
(SSE2/AVX/AVX2 を使えない環境でも動くことは動きますけどね)。
C99 や Fortran 2003 から使うためのインターフェイスもあります。
</p>
<p>
　ちなみに、Fortran で実装されたバージョンに興味のある方は、
<a href="shibafft.html">こちらのページ</a> へどうぞ。
</P>
<P>
　それにしても、FFTW より速いとは大きく出たなと思うでしょう。
でも、本当なんですよ。
まあ、特定の CPU 特定の系列長に限っての話ですけどね<code>(^^;</code>
それではベンチマーク結果を示しましょう。以下のようなベンチマークを行いました。
</P>
<OL>
    <LI><A HREF="#multithreads">OTFFT のマルチスレッドベンチマーク</A></LI>
    <LI><A HREF="single.html">OTFFT のシングルスレッドベンチマーク</A></LI>
    <LI><A HREF="amazonec2.html">Amazon EC2 による 32 並列のベンチマーク</A></LI>
</OL>
<P><A NAME="multithreads">
　ソースコードは <A HREF="node7.html#download">ダウンロードのページ</A>
で公開するとして(MIT ライセンスです)、
ここでは、マルチスレッド性能に関するベンチマークを示します。
実行環境は MacBook Pro 15 inch Late 2013(Haswell Core i7 2GHz) 上の
OS X El Capitan/GCC 5.3 です。OpenMP は Intel OpenMP Runtime を使いました。
比較した FFTW3 はバージョン 3.3.4 の <code>FFTW_ESTIMATE</code> です。
浮動小数点数の精度は倍精度です。
(MacPorts の GCC で AVX/AVX2 および Intel OpenMP Runtime を使いたい人は、
<a href="libiomp5.html">こちらのページ</a> をご参照ください)
</P>
<P STYLE="color:green">
※注　OTFFT は、Linux Mint 17.2 など一部の Linux でベンチマークすると、
OpenMP が謎の速度低下を起こすようです。
この現象を回避するには、Core i7(4 コア 8 スレッド)の場合、
環境変数 OMP_NUM_THREADS を 7 に設定すると良いようです。
</P>
<PRE>
------+-----------+-----------------+-----------------+-----------------+---
length|FFTW3[usec]|   OOURA   [usec]| SimpleFFT [usec]|   OTFFT   [usec]|err
------+-----------+-----------------+-----------------+-----------------+---
2^( 1)|       0.04|       0.02( 41%)|       0.02( 42%)|       0.01( 36%)| -
2^( 2)|       0.06|       0.03( 43%)|       0.04( 69%)|       0.02( 29%)| -
2^( 3)|       0.07|       0.06( 85%)|       0.07(108%)|       0.03( 43%)|-29
2^( 4)|       0.12|       0.12( 99%)|       0.16(138%)|       0.05( 46%)|-27
2^( 5)|       0.22|       0.40(184%)|       0.33(151%)|       0.12( 55%)|-26
2^( 6)|       0.52|       0.81(157%)|       0.77(149%)|       0.22( 42%)|-26
2^( 7)|       0.69|       1.78(256%)|       1.61(232%)|       0.52( 74%)|-25
2^( 8)|       1.43|       3.84(268%)|       3.68(257%)|       1.12( 78%)|-24
2^( 9)|       3.18|       8.61(270%)|       7.96(250%)|       2.55( 80%)|-24
2^(10)|       7.36|      18.37(250%)|      18.11(246%)|       6.41( 87%)|-23
2^(11)|      18.31|      41.29(225%)|      40.78(223%)|      14.54( 79%)|-22
2^(12)|      51.63|      91.29(177%)|     102.79(199%)|      24.82( 48%)|-21
2^(13)|     129.03|     229.29(178%)|     233.12(181%)|      54.11( 42%)|-20
2^(14)|     204.95|     389.47(190%)|     546.04(266%)|      92.96( 45%)|-20
2^(15)|     326.86|     717.99(220%)|     668.23(204%)|     160.23( 49%)|-20
2^(16)|     570.90|    1162.07(204%)|    1308.94(229%)|     339.94( 60%)|-19
2^(17)|    1156.83|    2202.24(190%)|    2499.68(216%)|     673.39( 58%)|-18
2^(18)|    3057.63|    4753.00(155%)|    5494.00(180%)|    1906.84( 62%)|-17
2^(19)|    9508.78|   10311.33(108%)|   15059.89(158%)|    5449.44( 57%)|-17
2^(20)|   20576.75|   22107.25(107%)|   33877.00(165%)|   10236.25( 50%)|-16
2^(21)|   45457.50|   44892.00( 99%)|   76684.00(169%)|   22056.50( 49%)|-16
2^(22)|  105727.00|   95352.00( 90%)|  180384.00(171%)|   66450.00( 63%)|-15
------+-----------+-----------------+-----------------+-----------------+---
 cost |   49819.71|   70165.35(141%)|   84434.12(169%)|   26348.73( 53%)|
------+-----------+-----------------+-----------------+-----------------+---
</PRE>
<P>
　length の欄は FFT の系列長を表しています。
そして、言うまでもなく FFTW3 の欄が FFTW3 での実行時間です。
DFT と IDFT の実行時間の和を表示しています。
OOURA の欄は大浦さんの FFT ライブラリ fftsg.c での実行時間です。
SimpleFFT の欄はごく単純な4基底の Cooley-Tukey アルゴリズムの実行時間です。
そして OTFFT の欄が私 OK おじさんが提案する FFT ライブラリでの実行時間です。
実行時間の単位はマイクロ秒で、
初期化の時間(FFTW3 のプランの作成等)は含まれていません。
括弧の中の％付きの数字は
FFTW3 の実行時間に対して何パーセントの実行時間になるかを表しています。
ただし、ベンチマーク結果が安定しなかったので、何度かベンチマークした結果、
OTFFT の成績が最も良くなる結果を選んだことを白状しておきます。
err の欄は FFTW3 と OTFFT の２乗誤差の対数です。
エラーチェックのために付けてあります。開発者用なので気にしないでください。
cost は全てのサイズで平均した速さの目安です。小さいほど高速です。
</P>
<P>
　どうでしょう。\(2^{22}\)のサイズまで OTFFT が FFTW3 より速くなっています。
cost で比較するとだいたい OTFFT が FFTW3 の 53% ほどの実行時間で済みます。
AVX が Stockham のアルゴリズムに見事にはまり、加えて C++ の template によって、
ループの長さがコンパイル時に決まる、
固定長のループになっているところが効いているのかもしれません。
</P>
<P>
　実はコア数が少ないと、例えば２の場合、
大浦さんのライブラリが大きなサイズの FFT で高い性能を示します。
OTFFT はコア数２の場合、大きなサイズでの成績はふるいません。
しかし、コア数が４(HT でスレッド数は８)になると、
ご覧の様に高い性能を示します。
OTFFT は並列処理に OpenMP の <code>#pragma omp for</code> を用いていますが、
構造が単純なので、スレッド数が増えた場合に性能が上がるようです。
</P>
<P>
　もう一つ、実行時間計測に FFT
用のオブジェクトの初期化の時間も含んだベンチマークも示しておきます。
ある意味こちらの時間が本当に必要な実行時間を示しているとも言えます。
FFT オブジェクトを初期化した後、
FFT を一回しか実行しない場合はこちらの時間を気にする必要があります。
</P>
<PRE>
------+-----------+-----------------+-----------------+-----------------
length|FFTW3[usec]|   OOURA   [usec]| SimpleFFT [usec]|   OTFFT   [usec]
------+-----------+-----------------+-----------------+-----------------
2^( 4)|      12.90|       0.36(  3%)|       0.40(  3%)|       0.42(  3%)
2^( 5)|      12.54|       0.65(  5%)|       0.63(  5%)|       0.60(  5%)
2^( 6)|      28.14|       1.14(  4%)|       1.20(  4%)|       0.64(  2%)
2^( 7)|      29.22|       2.27(  8%)|       2.32(  8%)|       1.16(  4%)
2^( 8)|      30.70|       4.57( 15%)|       4.94( 16%)|       2.02(  7%)
2^( 9)|      35.26|      10.02( 28%)|      10.21( 29%)|       4.08( 12%)
2^(10)|      38.78|      20.91( 54%)|      23.14( 60%)|      10.60( 27%)
2^(11)|      53.32|      46.28( 87%)|      51.55( 97%)|      27.01( 51%)
2^(12)|      93.87|     101.64(108%)|     131.61(140%)|      48.34( 51%)
2^(13)|     210.14|     251.31(120%)|     296.07(141%)|     103.07( 49%)
2^(14)|     629.67|     429.06( 68%)|     633.68(101%)|     192.26( 31%)
2^(15)|     826.25|     808.45( 98%)|     955.59(116%)|     344.34( 42%)
2^(16)|    1196.69|    1334.82(112%)|    1520.09(127%)|     391.66( 33%)
2^(17)|    1949.44|    2507.93(129%)|    2982.78(153%)|     773.24( 40%)
2^(18)|    5142.58|    5447.84(106%)|    6847.47(133%)|    3241.37( 63%)
2^(19)|   12350.33|   11202.56( 91%)|   17564.22(142%)|    7902.33( 64%)
2^(20)|   25720.00|   25905.75(101%)|   39442.00(153%)|   15377.50( 60%)
2^(21)|   56508.50|   49196.50( 87%)|   89376.50(158%)|   32448.50( 57%)
2^(22)|  124448.00|  111422.00( 90%)|  201481.00(162%)|  103594.00( 83%)
------+-----------+-----------------+-----------------+-----------------
 cost |  526178.47|   91973.87( 17%)|  117175.06( 22%)|   53286.84( 10%)
------+-----------+-----------------+-----------------+-----------------
</PRE>
<P>
　FFT オブジェクトの初期化も計測時間に含めた場合、
あまり小さなサイズの FFT では FFTW3 での実行時間が計測困難だったため、
系列長 \(2^4\) から計測を開始しています。
ご覧の様に、\(2^5\) から \(2^{22}\) のサイズまでは、
OTFFT がお得です。しかも、
よく使うと思われる系列長で、OTFFT がかなり速くなっております。
</P>
<P>
　つまり OTFFT は、内部で FFT を使うサブルーチンを書く場合に、
その場で FFT オブジェクトを作って１回だけ FFT を実行し、
そのまま捨てるような使い方をするときに有利です。
FFT を独立したコマンドにして、
スクリプトで呼び出すみたいな使い方をするとこの特徴がいきてきます。
</P>
<P>
　さて、FFT オブジェクトの初期化時間を含まないベンチマークの条件を、
<code>FFTW_ESTIMATE</code> にして誤摩化してないで、
とっとと <code>FFTW_MEASURE</code> で比較した結果を見せろ！
と言う方も居るかもしれませんので、一応結果を載せておきます。
こんな感じです。
</P>
<PRE>
------+-----------+-----------------+-----------------+-----------------+---
length|FFTW3[usec]|   OOURA   [usec]| SimpleFFT [usec]|   OTFFT   [usec]|err
------+-----------+-----------------+-----------------+-----------------+---
2^( 1)|       0.03|       0.02( 65%)|       0.02( 66%)|       0.01( 56%)| -
2^( 2)|       0.03|       0.02( 81%)|       0.04(141%)|       0.02( 58%)| -
2^( 3)|       0.05|       0.06(119%)|       0.07(154%)|       0.03( 60%)|-29
2^( 4)|       0.08|       0.12(145%)|       0.16(202%)|       0.05( 68%)|-27
2^( 5)|       0.16|       0.37(226%)|       0.33(201%)|       0.12( 74%)|-26
2^( 6)|       0.30|       0.79(265%)|       0.76(256%)|       0.22( 73%)|-26
2^( 7)|       0.63|       1.78(283%)|       1.61(256%)|       0.52( 83%)|-25
2^( 8)|       1.37|       3.81(278%)|       3.68(269%)|       1.09( 80%)|-24
2^( 9)|       3.32|       8.64(260%)|       7.91(238%)|       2.46( 74%)|-24
2^(10)|       7.14|      18.31(257%)|      17.99(252%)|       6.41( 90%)|-23
2^(11)|      17.01|      41.24(243%)|      40.59(239%)|      14.54( 86%)|-22
2^(12)|      45.32|      91.08(201%)|     103.07(227%)|      25.11( 55%)|-21
2^(13)|     113.78|     228.13(201%)|     232.74(205%)|      55.15( 48%)|-20
2^(14)|     192.50|     387.97(202%)|     538.39(280%)|      97.57( 51%)|-20
2^(15)|     327.25|     713.05(218%)|     673.30(206%)|     160.39( 49%)|-20
2^(16)|     551.28|    1170.49(212%)|    1325.45(240%)|     344.83( 63%)|-19
2^(17)|    1075.83|    2219.29(206%)|    2621.34(244%)|     688.78( 64%)|-18
2^(18)|    2740.74|    4769.32(174%)|    5716.84(209%)|    1996.68( 73%)|-17
2^(19)|    7109.00|   10730.56(151%)|   15180.00(214%)|    5490.78( 77%)|-17
2^(20)|   14574.25|   24951.25(171%)|   34338.25(236%)|   10358.25( 71%)|-16
2^(21)|   31463.50|   45588.00(145%)|   78702.50(250%)|   24267.00( 77%)|-16
2^(22)|   79452.00|  100221.00(126%)|  174924.00(220%)|   66733.00( 84%)|-15
------+-----------+-----------------+-----------------+-----------------+---
 cost |   39303.37|   70662.79(180%)|   84728.63(216%)|   26745.68( 68%)|
------+-----------+-----------------+-----------------+-----------------+---
</PRE>
<P>
　ところで、<A HREF="node7.html#download">ダウンロードのページ</A> から
OTFFT をダウンロードしてご自分の環境で試したという方が居たとして、
その実行結果がここに示されている結果と一致しなくとも驚かないでください。
実行結果は環境によってまちまちです。
CPU とかが違えばまったく違った結果が出ますし、
CPU が同じでも Linux の GCC でコンパイルしたりすると、
また違った結果が出ます。それに FFTW3 は日々進歩しています。
新しいテクノロジーが登場すると積極的にそれを採用しています。
ですから、あなたがこのページを見て試すころには FFTW3
が進歩して OTFFT が陳腐化しているかもしれません。
そんなわけで、ここに書いてある通りにならなくともご了承ください。
</P>
<HR>
<A NAME="tex2html51"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html49"
  HREF="stockham.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html43"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A>   <BR>
<B> Next:</B> <A NAME="tex2html52"
  HREF="node5.html">5 OTFFT の使い方</A>
<B>Up:</B> <A NAME="tex2html50"
  HREF="stockham.html">stockham</A>
<B> Previous:</B> <A NAME="tex2html44"
  HREF="node3.html">3 4基底の Stockham FFT</A>
<B> Reference:</B> <A HREF="shibafft.html">ShibaFFT -- Fortran90 で書かれた混合基数 FFT ライブラリ</A>
</BODY>
</HTML>
