<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="description" content="FFTW より速い FFT ライブラリの紹介">
<meta name="keywords" content="Stockham FFT,ベンチマーク,benchmark">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="stockham.css" type="text/css">
<link rel="next" href="node5.html">
<link rel="prev" href="node3.html">
<link rel="up" href="stockham.html">

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript" src="ga.js"></script>

<title>OTFFT -- FFTW より速い FFT ライブラリ</title>
</head>
<body>
<b>Next:</b> <a href="node5.html">OTFFT の使い方</a>
<b>Up:</b> <a href="stockham.html">トップページ</a>
<b>Previous:</b> <a href="node3.html">４基底の Stockham FFT</a>
<b>Reference:</b> <a href="node7.html">ダウンロード</a>,&nbsp;
<a href="http://www.moon.sannet.ne.jp/okahisa/otfft-en/">English Page</a>
<hr>

<h1><a name="otfft"></a>
OTFFT -- FFTW より速い FFT ライブラリ
</h1>
<p>
　<a href="node1.html">セクション1</a>, <a href="node2.html">セクション2</a>,
<a href="node3.html">セクション3</a> で、
せっかく高速な Stockham FFT アルゴリズムを導いたのですから、
実際にそれを使ったらどうなるか試してみたいですよね。
そこで、Stockham のアルゴリズムを用いた FFT ライブラリを作ってみました。
その名も OTFFT です(OK おじさん Template FFT の略)。
実はこっそり <a href="node11.html">Six-Step FFT アルゴリズム</a> も使ってます。
その他、アルゴリズムではありませんが、
C++ の template によるメタプログラミング技法を駆使し、
さらに、SSE2/AVX/AVX2 イントリンシックを用いて実装してあります。
ですから、Intel アーキテクチャ CPU 専用ライブラリです
(SSE2/AVX/AVX2 を使えない環境でも動くことは動きますけどね)。
C99 や Fortran 2003 から使うためのインターフェイスもあります。
</p>
<p>
　ちなみに、Fortran で実装されたバージョンに興味のある方は、
<a href="http://www.moon.sannet.ne.jp/okahisa/shibafft/">こちらのページ</a>
へどうぞ。
</p>
<p>
　それにしても、FFTW より速いとは大きく出たなと思うでしょう。
でも、本当なんですよ。
まあ、特定の CPU 特定の系列長に限っての話ですけどね<code>(^^;</code>
それではベンチマーク結果を示しましょう。以下のようなベンチマークを行いました。
</p>
<ol>
    <li><a href="#multithreads">OTFFT のマルチスレッドベンチマーク</a></li>
    <li><a href="single.html">OTFFT のシングルスレッドベンチマーク</a></li>
    <li><a href="amazonec2.html">Amazon EC2 による 32 並列のベンチマーク</a></li>
</ol>
<p><a name="multithreads">
　ソースコードは <a href="node7.html#download">ダウンロードのページ</a>
で公開するとして(MIT ライセンスです)、
ここでは、マルチスレッド性能に関するベンチマークを示します。
ベンチマークの条件は以下の通りです。
</p>
<table style="padding-left:1em">
    <tr>
        <td>Machine:</td><td>MacBook Pro 15 inch Late 2013(Haswell Core i7 2GHz)</td>
    </tr>
    <tr>
        <td>OS:</td><td>OS X El Capitan</td>
    </tr>
    <tr>
        <td>Compiler:</td><td>Clang 3.9</td>
    </tr>
    <tr>
        <td>OpenMP Runtime:</td><td>libomp (Clang default)</td>
    </tr>
    <tr>
        <td>cores/threads:</td><td>4 cores/8 threads</td>
    </tr>
    <tr>
        <td>FFTW Version:</td><td>3.3.5</td>
    </tr>
    <tr>
        <td>FFTW Mode:</td><td>FFTW_ESTIMATE (AVX2 enabled)</td>
    </tr>
    <tr>
        <td>浮動小数点数の精度:</td><td>倍精度</td>
    </tr>
</table>
<p>
マルチスレッド性能に関するベンチマーク結果は以下のようになります。
</p>
<p STYLE="color:green">
※注　OTFFT は、Linux Mint 17.2 など一部の Linux でベンチマークすると、
OpenMP が謎の速度低下を起こすようです。
この現象を回避するには、Core i7(4 コア 8 スレッド)の場合、
環境変数 OMP_NUM_THREADS を 7 に設定すると良いようです。
</p>
<pre>
------+-----------+-----------------+-----------------+-----------------+---
length|FFTW3[usec]|   OOURA   [usec]| SimpleFFT [usec]|   OTFFT   [usec]|err
------+-----------+-----------------+-----------------+-----------------+---
2^( 1)|       0.03|       0.02( 67%)|       0.02( 70%)|       0.01( 40%)| -
2^( 2)|       0.03|       0.02( 76%)|       0.05(151%)|       0.01( 40%)| -
2^( 3)|       0.04|       0.05(124%)|       0.08(187%)|       0.02( 55%)|-28
2^( 4)|       0.08|       0.11(141%)|       0.18(238%)|       0.05( 64%)|-27
2^( 5)|       0.15|       0.36(239%)|       0.33(222%)|       0.11( 76%)|-27
2^( 6)|       0.50|       1.17(234%)|       0.81(161%)|       0.21( 42%)|-26
2^( 7)|       1.08|       1.84(171%)|       1.59(148%)|       0.51( 47%)|-25
2^( 8)|       2.31|       4.10(178%)|       3.81(165%)|       1.11( 48%)|-24
2^( 9)|       4.91|       9.07(185%)|       7.74(158%)|       2.62( 53%)|-24
2^(10)|      10.91|      19.99(183%)|      18.09(166%)|       6.38( 59%)|-22
2^(11)|      26.73|      44.55(167%)|      39.48(148%)|      14.05( 53%)|-22
2^(12)|      84.72|     100.31(118%)|     103.86(123%)|      25.79( 30%)|-21
2^(13)|     207.57|     239.33(115%)|     234.36(113%)|      53.24( 26%)|-20
2^(14)|     237.80|     413.84(174%)|     530.25(223%)|      90.37( 38%)|-20
2^(15)|     401.52|     777.11(194%)|     758.84(189%)|     155.51( 39%)|-19
2^(16)|     770.13|    1231.36(160%)|    1504.77(195%)|     326.02( 42%)|-19
2^(17)|    1558.22|    2439.50(157%)|    3193.87(205%)|     719.39( 46%)|-18
2^(18)|    3762.74|    5325.64(142%)|    6629.26(176%)|    1984.04( 53%)|-17
2^(19)|   10459.98|   10669.39(102%)|   16884.70(161%)|    5437.41( 52%)|-16
2^(20)|   22462.21|   23596.81(105%)|   40720.60(181%)|   10314.34( 46%)|-16
2^(21)|   46752.57|   47127.00(101%)|   89848.93(192%)|   23975.70( 51%)|-15
2^(22)|  111337.60|   99839.08( 90%)|  197543.64(177%)|   69247.60( 62%)|-15
------+-----------+-----------------+-----------------+-----------------+---
 cost |   55476.08|   74662.88(135%)|   91483.50(165%)|   25713.56( 46%)|
------+-----------+-----------------+-----------------+-----------------+---
</pre>
<p>
　length の欄は FFT の系列長を表しています。
そして、言うまでもなく FFTW3 の欄が FFTW3 での実行時間です。
DFT と IDFT の実行時間の和を表示しています。
OOURA の欄は大浦さんの FFT ライブラリ fftsg.c での実行時間です。
SimpleFFT の欄はごく単純な4基底の Cooley-Tukey アルゴリズムの実行時間です。
そして OTFFT の欄が私 OK おじさんが提案する FFT ライブラリでの実行時間です。
実行時間の単位はマイクロ秒で、
初期化の時間(FFTW3 のプランの作成等)は含まれていません。
括弧の中の％付きの数字は
FFTW3 の実行時間に対して何パーセントの実行時間になるかを表しています。
ただし、ベンチマーク結果が安定しなかったので、何度かベンチマークした結果、
OTFFT の成績が最も良くなる結果を選んだことを白状しておきます。
err の欄は FFTW3 と OTFFT の２乗誤差の対数です。
エラーチェックのために付けてあります。開発者用なので気にしないでください。
cost は全てのサイズで平均した速さの目安です。小さいほど高速です。
</p>
<p>
　どうでしょう。\(2^{22}\)のサイズまで OTFFT が FFTW3 より速くなっています。
cost で比較するとだいたい OTFFT が FFTW3 の 46% ほどの実行時間で済みます。
AVX が Stockham のアルゴリズムに見事にはまり、加えて C++ の template によって、
ループの長さがコンパイル時に決まる、
固定長のループになっているところが効いているのかもしれません。
</p>
<p style="color:green">
　現在、Mac でのベンチマークには Clang を採用していますが、
以前は GCC を利用していました。GCC でしか OpenMP が使えなかったからです。
しかし、GCC の OpenMP は Linux に最適化されており、
Mac でパフォーマンスを出そうとすると
Intel OpenMP Runtime をインストールする必要がありました。
現在、Clang も OpenMP 対応を果たし、
簡単に AVX と OpenMP が使えるようになりました。
なので、コンパイラを MacPorts の Clang に変更しました。
もし、GCC でコンパイルしたいのなら、
<a href="libiomp5.html">こちらのページ</a> をご参照ください。
</p>
<p>
　もう一つ、実行時間計測に FFT
用のオブジェクトの初期化の時間も含んだベンチマークも示しておきます。
ある意味こちらの時間が本当に必要な実行時間を示しているとも言えます。
FFT オブジェクトを初期化した後、
FFT を一回しか実行しない場合はこちらの時間を気にする必要があります。
</p>
<pre>
------+-----------+-----------------+-----------------+-----------------
length|FFTW3[usec]|   OOURA   [usec]| SimpleFFT [usec]|   OTFFT   [usec]
------+-----------+-----------------+-----------------+-----------------
2^( 4)|      14.19|       0.61(  4%)|       0.76(  5%)|       0.74(  5%)
2^( 5)|      14.22|       1.06(  7%)|       0.97(  7%)|       0.86(  6%)
2^( 6)|      30.71|       1.61(  5%)|       1.44(  5%)|       0.67(  2%)
2^( 7)|      32.42|       2.59(  8%)|       2.43(  7%)|       1.09(  3%)
2^( 8)|      35.25|       4.94( 14%)|       4.85( 14%)|       2.00(  6%)
2^( 9)|      39.92|      10.38( 26%)|       9.71( 24%)|       3.95( 10%)
2^(10)|      46.60|      22.03( 47%)|      22.01( 47%)|       9.34( 20%)
2^(11)|      65.98|      48.33( 73%)|      47.73( 72%)|      21.83( 33%)
2^(12)|     126.86|     108.50( 86%)|     121.82( 96%)|      41.06( 32%)
2^(13)|     301.21|     254.33( 84%)|     270.73( 90%)|      87.25( 29%)
2^(14)|     691.21|     439.77( 64%)|     602.26( 87%)|     157.17( 23%)
2^(15)|     983.70|     837.65( 85%)|     999.51(102%)|     293.44( 30%)
2^(16)|    1445.94|    1356.45( 94%)|    1721.92(119%)|     372.50( 26%)
2^(17)|    2663.24|    2618.42( 98%)|    3686.21(138%)|    1336.75( 50%)
2^(18)|    6294.97|    5872.97( 93%)|    7981.12(127%)|    3261.46( 52%)
2^(19)|   13948.13|   11900.91( 85%)|   19825.69(142%)|    8175.69( 59%)
2^(20)|   29363.70|   26454.50( 90%)|   45719.70(156%)|   16210.02( 55%)
2^(21)|   57713.00|   51740.73( 90%)|  101143.79(175%)|   34519.04( 60%)
2^(22)|  134618.67|  112548.43( 84%)|  227791.07(169%)|  103751.14( 77%)
------+-----------+-----------------+-----------------+-----------------
 cost |  590023.82|  103421.75( 18%)|  130845.42( 22%)|   58237.94( 10%)
------+-----------+-----------------+-----------------+-----------------
</pre>
<p>
　FFT オブジェクトの初期化も計測時間に含めた場合、
あまり小さなサイズの FFT では FFTW3 での実行時間が計測困難だったため、
系列長 \(2^4\) から計測を開始しています。
ご覧の様に、\(2^5\) から \(2^{22}\) のサイズまでは、
OTFFT がお得です。しかも、
よく使うと思われる系列長で、OTFFT がかなり速くなっております。
</p>
<p>
　つまり OTFFT は、内部で FFT を使うサブルーチンを書く場合に、
その場で FFT オブジェクトを作って１回だけ FFT を実行し、
そのまま捨てるような使い方をするときに有利です。
FFT を独立したコマンドにして、
スクリプトで呼び出すみたいな使い方をするとこの特徴がいきてきます。
</p>
<p>
　さて、FFT オブジェクトの初期化時間を含まないベンチマークの条件を、
<code>FFTW_ESTIMATE</code> にして誤摩化してないで、
とっとと <code>FFTW_MEASURE</code> で比較した結果を見せろ！
と言う方も居るかもしれませんので、一応結果を載せておきます。
こんな感じです。
</p>
<pre>
------+-----------+-----------------+-----------------+-----------------+---
length|FFTW3[usec]|   OOURA   [usec]| SimpleFFT [usec]|   OTFFT   [usec]|err
------+-----------+-----------------+-----------------+-----------------+---
2^( 1)|       0.03|       0.02( 61%)|       0.02( 63%)|       0.01( 35%)| -
2^( 2)|       0.03|       0.02( 70%)|       0.05(140%)|       0.01( 37%)| -
2^( 3)|       0.05|       0.05(108%)|       0.08(159%)|       0.02( 47%)|-28
2^( 4)|       0.08|       0.11(126%)|       0.18(212%)|       0.05( 55%)|-27
2^( 5)|       0.15|       0.35(227%)|       0.33(215%)|       0.11( 71%)|-27
2^( 6)|       0.30|       0.82(278%)|       0.80(272%)|       0.21( 72%)|-26
2^( 7)|       0.60|       1.83(307%)|       1.58(264%)|       0.51( 85%)|-25
2^( 8)|       1.47|       4.09(278%)|       3.71(252%)|       1.13( 77%)|-24
2^( 9)|       3.13|       9.10(290%)|       7.76(248%)|       2.52( 81%)|-24
2^(10)|       7.43|      19.93(268%)|      17.87(241%)|       6.39( 86%)|-22
2^(11)|      19.06|      44.71(235%)|      38.83(204%)|      15.80( 83%)|-22
2^(12)|      54.13|      99.85(184%)|     104.67(193%)|      25.84( 48%)|-21
2^(13)|     114.61|     238.22(208%)|     231.52(202%)|      53.55( 47%)|-20
2^(14)|     194.50|     407.68(210%)|     521.16(268%)|      91.98( 47%)|-20
2^(15)|     308.90|     770.51(249%)|     753.51(244%)|     159.99( 52%)|-19
2^(16)|     545.32|    1230.29(226%)|    1481.58(272%)|     347.50( 64%)|-19
2^(17)|    1110.43|    2430.76(219%)|    2966.43(267%)|     668.54( 60%)|-18
2^(18)|    2701.10|    5433.12(201%)|    6741.33(250%)|    1827.76( 68%)|-17
2^(19)|    7140.51|   10853.81(152%)|   17510.32(245%)|    5401.47( 76%)|-16
2^(20)|   14757.18|   25054.30(170%)|   40240.88(273%)|   11071.52( 75%)|-16
2^(21)|   30981.11|   48469.36(156%)|   90813.36(293%)|   22419.73( 72%)|-15
2^(22)|   77581.87|  105130.87(136%)|  199162.79(257%)|   67919.80( 88%)|-15
------+-----------+-----------------+-----------------+-----------------+---
 cost |   40139.28|   74161.12(185%)|   91068.45(227%)|   25640.82( 64%)|
------+-----------+-----------------+-----------------+-----------------+---
</pre>
<p>
　ところで、<a href="node7.html#download">ダウンロードのページ</a> から
OTFFT をダウンロードしてご自分の環境で試したという方が居たとして、
その実行結果がここに示されている結果と一致しなくとも驚かないでください。
実行結果は環境によってまちまちです。
CPU とかが違えばまったく違った結果が出ますし、
CPU が同じでも Linux の GCC でコンパイルしたりすると、
また違った結果が出ます。それに FFTW3 は日々進歩しています。
新しいテクノロジーが登場すると積極的にそれを採用しています。
ですから、あなたがこのページを見て試すころには FFTW3
が進歩して OTFFT が陳腐化しているかもしれません。
そんなわけで、ここに書いてある通りにならなくともご了承ください。
</p>

<hr>
<b>Next:</b> <a href="node5.html">OTFFT の使い方</a>
<b>Up:</b> <a href="stockham.html">トップページ</a>
<b>Previous:</b> <a href="node3.html">４基底の Stockham FFT</a>
<b>Reference:</b> <a href="http://www.moon.sannet.ne.jp/okahisa/shibafft/">ShibaFFT -- Fortran90 で書かれた混合基数 FFT ライブラリ</a>
</body>
</html>
