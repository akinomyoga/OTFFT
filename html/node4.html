<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="description" CONTENT="4 FFTW より速い FFT ライブラリ OTFFT">
<META NAME="keywords" CONTENT="stockham fft,ベンチマーク,benchmark">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<LINK REL="STYLESHEET" HREF="stockham.css" TYPE="text/css">
<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="stockham.html">
<LINK REL="next" HREF="node5.html">

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript" src="ga.js"></script>

<TITLE>4 FFTW より速い FFT ライブラリ OTFFT</TITLE>
</HEAD>
<BODY>
<A NAME="tex2html51"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html49"
  HREF="stockham.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html43"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A>   <BR>
<B> Next:</B> <A NAME="tex2html52"
  HREF="node5.html">5 OTFFT の使い方</A>
<B>Up:</B> <A NAME="tex2html50"
  HREF="stockham.html">stockham</A>
<B> Previous:</B> <A NAME="tex2html44"
  HREF="node3.html">3 4基底の Stockham FFT</A>
<BR>

<H1><A NAME="SECTION00040000000000000000"></A><A NAME="otfft"></A>
4 FFTW より速い FFT ライブラリ OTFFT
</H1>
<P>
　<A HREF="node1.html">セクション1</A>, <A HREF="node2.html">セクション2</A>,
<A HREF="node3.html">セクション3</A>で、
せっかく高速な Stockham FFT アルゴリズムを導いたのですから、
実際にそれを使ったらどうなるか試してみたいですよね。
そこで、Stockham のアルゴリズムを用いた FFT ライブラリを作ってみました。
その名も OTFFT です。実はこっそり Sixstep FFT アルゴリズムも使ってます。
Sixstep FFT に関しては適当にググってみてください。
その他、アルゴリズムではありませんが、
C++ の template によるメタプログラミング技法を駆使し、
さらに、SSE2/AVX/AVX2 イントリンシックを用いて実装してあります。
ですから、Intel アーキテクチャ CPU 専用ライブラリです
(SSE2/AVX/AVX2 を使えない環境でも動くことは動きますけどね)。
</P>
<P>
　それにしても FFTW より高速とは大きく出たなと思われるでしょう。
何かインチキがあるんじゃないかと思うかもしれません。はい、インチキです。
種を明かすと FFTW の <code>FFTW_ESTIMATE</code> を比較対象としています。
でも、普通の人は <code>FFTW_MEASURE</code> とか使ったりしないですよね
<code>(^^;</code>
まあ、こう言うセンセーショナルなタイトルの方が Web での食いつきが良いので、
あえてやってます。わはは。
念のため説明しておきますが、
一応、FFTW 側でも SSE2/AVX を有効にしてベンチマークしましたよ。
</P>
<H3 STYLE="color:green">【追記】</H3>
<P STYLE="color:green">
　その後、OTFFT のバージョンアップを繰り返した結果、
<code>FFTW_MEASURE</code> が比較対象でも、OTFFT の方が速いと言えるんじゃね？
というところまでこぎ着けました。詳細はこのページの後半に書いてあります。
</P>
<H3 STYLE="color:green">【追記の追記】</H3>
<P STYLE="color:green">
　さらにその後、Linux Mint 17.2 など新しい Linux でベンチマークすると、
OpenMP が謎の速度低下を起こすようになりました。
この現象を回避するには、Core i7(4 コア 8 スレッド)の場合、
環境変数 OMP_NUM_THREADS を 7 に設定すると良いようです。
</P>
<P>
　ソースコードは <A HREF="node7.html#download">ダウンロードのページA</A>
で公開するとして、早速ベンチマーク結果を示しましょう。
実行環境は
MacBook Pro 15 inch Late 2013(Haswell Core i7 2GHz) 上の OS X Yosemite/GCC 5.2
です。OpenMP は Intel OpenMP Runtime を使いました。
比較した FFTW3 のバージョンは 3.3.4 です。
浮動小数点数の精度は倍精度です。
(MacPorts の GCC で AVX/AVX2 および Intel OpenMP Runtime を使いたい人は、
<a href="libiomp5.html">こちらのページ</a> をご参照ください)
</P>
<PRE>
------+-----------+-----------------+-----------------+-----------------+---
length|FFTW3[usec]|   OOURA   [usec]| SimpleFFT [usec]|   OTFFT   [usec]|err
------+-----------+-----------------+-----------------+-----------------+---
2^( 1)|       0.04|       0.02( 41%)|       0.02( 46%)|       0.01( 30%)| -
2^( 2)|       0.05|       0.02( 52%)|       0.05(103%)|       0.02( 32%)| -
2^( 3)|       0.07|       0.06( 79%)|       0.12(161%)|       0.03( 36%)|-28
2^( 4)|       0.12|       0.12(100%)|       0.18(150%)|       0.05( 45%)|-29
2^( 5)|       0.22|       0.37(169%)|       0.47(216%)|       0.12( 54%)|-28
2^( 6)|       0.34|       0.79(233%)|       0.79(232%)|       0.22( 63%)|-28
2^( 7)|       0.69|       1.76(256%)|       2.34(340%)|       0.53( 77%)|-28
2^( 8)|       1.43|       3.83(267%)|       3.79(265%)|       1.10( 76%)|-28
2^( 9)|       3.19|       9.29(291%)|      10.69(335%)|       2.50( 78%)|-28
2^(10)|       7.33|      18.53(253%)|      18.37(251%)|       6.67( 91%)|-28
2^(11)|      17.79|      41.16(231%)|      52.92(298%)|      17.43( 98%)|-27
2^(12)|      51.42|      91.40(178%)|     104.26(203%)|      26.38( 51%)|-27
2^(13)|     125.83|     227.63(181%)|     288.13(229%)|      53.90( 43%)|-27
2^(14)|     205.69|     391.29(190%)|     551.87(268%)|      96.20( 47%)|-27
2^(15)|     325.95|     715.89(220%)|     696.18(214%)|     179.13( 55%)|-27
2^(16)|     570.53|    1168.85(205%)|    1350.35(237%)|     382.75( 67%)|-27
2^(17)|    1145.95|    2172.63(190%)|    2797.73(244%)|     768.90( 67%)|-27
2^(18)|    2906.68|    4804.05(165%)|    5675.37(195%)|    2050.21( 71%)|-27
2^(19)|    9602.56|    9925.00(103%)|   15829.67(165%)|    5743.11( 60%)|-27
2^(20)|   20485.25|   22099.75(108%)|   34538.25(169%)|   11116.50( 54%)|-27
2^(21)|   45408.00|   43130.50( 95%)|   79000.00(174%)|   23935.00( 53%)|-27
2^(22)|  106645.00|   96152.00( 90%)|  177706.00(167%)|   68152.00( 64%)|-27
------+-----------+-----------------+-----------------+-----------------+---
 cost |   48548.40|   69839.55(144%)|   93096.57(192%)|   27280.14( 56%)|
------+-----------+-----------------+-----------------+-----------------+---
</PRE>
<P>
　length の欄は FFT のサイズを表しています。
そして、言うまでもなく FFTW3 の欄が FFTW3 での実行時間です。
DFT と IDFT の実行時間の和を表示しています。
OOURA の欄は大浦さんの FFT ライブラリ fftsg.c での実行時間です。
SimpleFFT の欄はごく単純な4基底の Cooley-Tukey アルゴリズムの実行時間です。
そして OTFFT の欄が私OKおじさんが提案する FFT ライブラリでの実行時間です。
実行時間の単位はマイクロ秒で、
初期化の時間(FFTW3 のプランの作成等)は含まれていません。
括弧の中の％付きの数字は
FFTW3 の実行時間に対して何パーセントの実行時間になるかを表しています。
ただし、ベンチマーク結果が安定しなかったので、何度かベンチマークした結果、
OTFFT の成績が最も良くなる結果を選んだことを白状しておきます。
err の欄は FFTW3 と OTFFT の２乗誤差の対数です。
エラーチェックのために付けてあります。開発者用なので気にしないでください。
cost は全てのサイズで平均した速さの目安です。小さいほど高速です。
</P>
<P>
　どうでしょう。\(2^{22}\)のサイズまで OTFFT が FFTW3 より速くなっています。
cost で比較するとだいたい OTFFT が FFTW3 の 56% ほどの実行時間で済みます。
AVX が Stockham のアルゴリズムに見事にはまり、加えて C++ の template によって、
ループの長さがコンパイル時に決まる、
固定長のループになっているところが効いているのかもしれません。
</P>
<P>
　実はコア数が少ないと、例えば２の場合、
大浦さんのライブラリが大きなサイズの FFT で高い性能を示します。
OTFFT はコア数２の場合、大きなサイズでの成績はふるいません。
しかし、コア数が４(HT でスレッド数は８)になると、
ご覧の様に高い性能を示します。
OTFFT は並列処理に OpenMP の <code>#pragma omp for</code> を用いていますが、
構造が単純なので、スレッド数が増えた場合に性能が上がるようです。
</P>
<P>
　もう一つ、実行時間計測に FFT
用のオブジェクトの初期化の時間も含んだベンチマークも示しておきます。
ある意味こちらの時間が本当に必要な実行時間を示しているとも言えます。
FFT オブジェクトを初期化した後、
FFT を一回しか実行しない場合はこちらの時間を気にする必要があります。
</P>
<PRE>
------+-----------+-----------------+-----------------+-----------------
length|FFTW3[usec]|   OOURA   [usec]| SimpleFFT [usec]|   OTFFT   [usec]
------+-----------+-----------------+-----------------+-----------------
2^( 4)|      13.08|       0.34(  3%)|       0.41(  3%)|       0.94(  7%)
2^( 5)|      13.20|       0.64(  5%)|       0.81(  6%)|       1.11(  8%)
2^( 6)|      29.56|       1.15(  4%)|       1.26(  4%)|       1.24(  4%)
2^( 7)|      34.83|       2.28(  7%)|       3.04(  9%)|       1.69(  5%)
2^( 8)|      32.44|       4.59( 14%)|       4.96( 15%)|       2.54(  8%)
2^( 9)|      35.11|       9.98( 28%)|      13.12( 37%)|       4.67( 13%)
2^(10)|      40.54|      21.18( 52%)|      22.84( 56%)|      11.26( 28%)
2^(11)|      57.14|      46.23( 81%)|      64.63(113%)|      31.96( 56%)
2^(12)|      93.78|     101.42(108%)|     131.91(141%)|      51.95( 55%)
2^(13)|     209.10|     250.34(120%)|     359.15(172%)|     107.21( 51%)
2^(14)|     630.00|     435.42( 69%)|     631.18(100%)|     190.34( 30%)
2^(15)|     830.76|     811.30( 98%)|     969.79(117%)|     360.52( 43%)
2^(16)|    1207.61|    1312.85(109%)|    1550.40(128%)|     439.28( 36%)
2^(17)|    1953.29|    2476.59(127%)|    3145.71(161%)|     886.32( 45%)
2^(18)|    5246.42|    5416.95(103%)|    6814.00(130%)|    3458.95( 66%)
2^(19)|   12416.22|   11536.67( 93%)|   17695.44(143%)|    8174.44( 66%)
2^(20)|   26030.25|   25900.75(100%)|   39303.25(151%)|   16654.75( 64%)
2^(21)|   54413.00|   50434.50( 93%)|   89237.50(164%)|   33663.50( 62%)
2^(22)|  125220.00|  112342.00( 90%)|  202771.00(162%)|  102393.00( 82%)
------+-----------+-----------------+-----------------+-----------------
 cost |  550092.33|   91948.17( 17%)|  124957.78( 23%)|   69681.56( 13%)
------+-----------+-----------------+-----------------+-----------------
</PRE>

<P>
　FFT オブジェクトの初期化も計測時間に含めた場合、
あまり小さなサイズの FFT では FFTW3 での実行時間が計測困難だったため、
サイズ \(2^4\) から計測を開始しています。
ご覧の様に、\(2^{22}\) のサイズまでは、OTFFT が FFTW3 に、
それなりの差をつけてお得になっております。
</P>
<P>
　つまり OTFFT は、内部で FFT を使うサブルーチンを書く場合に、
その場で FFT オブジェクトを作って１回だけ FFT を実行し、
そのまま捨てるような使い方をするときに有利です。
効率を考えるなら、サブルーチンの外部で FFT オブジェクトを初期化して、
それを引数に渡すような書き方になるでしょう。
しかし、実際にはそういう書き方は面倒ですよね。
</P>
<P>
　さて、FFT オブジェクトの初期化を含まない場合のベンチマークを、
<code>FFTW_ESTIMATE</code> で誤摩化してないで、
とっとと <code>FFTW_MEASURE</code> で比較した結果を見せろ！
と言う方も居るかもしれませんので、一応結果を載せておきます。
こんな感じです。<S>結構がんばってるでしょ？</S>
</P>
<H3 STYLE="color: green">【追記】</H3>
<P STYLE="color: green">
　その後、OTFFT のバージョンアップを繰り返した結果、
<code>FFTW_MEASURE</code> が比較対象でも、OTFFT の方が速いと言えるんじゃね？
というところまでこぎ着けました。ヤバいぜ OTFFT <code>(^^;</code>
</P>
<PRE>
------+-----------+-----------------+-----------------+-----------------+---
length|FFTW3[usec]|   OOURA   [usec]| SimpleFFT [usec]|   OTFFT   [usec]|err
------+-----------+-----------------+-----------------+-----------------+---
2^( 1)|       0.03|       0.02( 65%)|       0.02( 72%)|       0.01( 46%)| -
2^( 2)|       0.03|       0.02( 81%)|       0.05(159%)|       0.02( 49%)| -
2^( 3)|       0.04|       0.06(138%)|       0.12(283%)|       0.03( 63%)|-28
2^( 4)|       0.08|       0.12(143%)|       0.18(213%)|       0.05( 64%)|-29
2^( 5)|       0.15|       0.37(245%)|       0.47(310%)|       0.12( 77%)|-28
2^( 6)|       0.31|       0.80(258%)|       0.79(256%)|       0.23( 76%)|-28
2^( 7)|       0.62|       1.76(281%)|       2.24(359%)|       0.52( 84%)|-28
2^( 8)|       1.42|       3.83(270%)|       3.78(266%)|       1.08( 76%)|-28
2^( 9)|       3.32|       8.57(258%)|      10.72(323%)|       2.46( 74%)|-28
2^(10)|       7.13|      18.61(261%)|      18.38(258%)|       6.54( 92%)|-28
2^(11)|      16.81|      41.03(244%)|      52.70(314%)|      17.75(106%)|-27
2^(12)|      43.01|      91.19(212%)|     104.51(243%)|      26.69( 62%)|-27
2^(13)|     109.68|     229.31(209%)|     288.24(263%)|      54.92( 50%)|-27
2^(14)|     198.23|     391.47(197%)|     543.53(274%)|      94.09( 47%)|-27
2^(15)|     312.42|     710.11(227%)|     704.96(226%)|     182.64( 58%)|-27
2^(16)|     545.27|    1157.94(212%)|    1361.61(250%)|     392.58( 72%)|-27
2^(17)|    1131.05|    2176.29(192%)|    2783.27(246%)|     784.76( 69%)|-27
2^(18)|    2564.84|    4777.05(186%)|    5623.68(219%)|    2136.79( 83%)|-27
2^(19)|    7253.56|    9916.00(137%)|   15555.89(214%)|    5766.22( 79%)|-27
2^(20)|   14683.00|   22094.75(150%)|   33923.00(231%)|   11172.25( 76%)|-27
2^(21)|   31014.00|   43661.50(141%)|   78897.50(254%)|   23046.00( 74%)|-27
2^(22)|   79325.00|   94414.00(119%)|  174003.00(219%)|   67751.00( 85%)|-27
------+-----------+-----------------+-----------------+-----------------+---
 cost |   38875.57|   69486.31(179%)|   92421.14(238%)|   27329.85( 70%)|
------+-----------+-----------------+-----------------+-----------------+---
</PRE>

<P>
　ところで、<A HREF="node7.html#download">ダウンロードのページA</A> から
OTFFT をダウンロードしてご自分の環境で試したという方が居たとして、
その実行結果がここに示されている結果と一致しなくとも驚かないでください。
実行結果は環境によってまちまちです。
CPU とかが違えばまったく違った結果が出ますし、
CPU が同じでも Linux の GCC でコンパイルしたりすると、
また違った結果が出ます。それに FFTW3 は日々進歩しています。
新しいテクノロジーが登場すると積極的にそれを採用しています。
ですから、あなたがこのページを見て試すころには FFTW3
が進歩して OTFFT が陳腐化しているかもしれません。
そんなわけで、ここに書いてある通りにならなくともご了承ください。
</P>

<HR>
<A NAME="tex2html51"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html49"
  HREF="stockham.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html43"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A>   <BR>
<B> Next:</B> <A NAME="tex2html52"
  HREF="node5.html">5 OTFFT の使い方</A>
<B>Up:</B> <A NAME="tex2html50"
  HREF="stockham.html">stockham</A>
<B> Previous:</B> <A NAME="tex2html44"
  HREF="node3.html">3 4基底の Stockham FFT</A>
</BODY>
</HTML>
