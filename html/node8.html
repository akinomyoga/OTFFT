<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="description" content="Stockham アルゴリズムの種類">
<meta name="keywords" content="stockham">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" HREF="stockham.css" type="text/css">
<link rel="prev" HREF="node7.html">
<link rel="up" HREF="stockham.html">

<script type="text/javascript" src="ga.js"></script>

<title>Stockham のアルゴリズムの種類</title>
</head>
<body>
<b>Next:</b> <a HREF="optimize1.html">配列へアクセスを減らす最適化</a>
<b>Up:</b> <a HREF="stockham.html">トップページ</a>
<b>Previous:</b> <a HREF="node7.html">ダウンロード</a>
<hr>

<h1><a name="kindsofstockham"></a>
Stockham のアルゴリズムの種類
</h1>
　ここでは、私が Web を検索して見つけた
Stockham のアルゴリズムの種類について整理しておきます。まず、
このサイトで説明されている Cooley-Tukey のアルゴリズムからの単純な変形で導ける
Stockham のアルゴリズムをタイプ１。
私がなぜこれでフーリエ変換できるのか説明できない
Stockham のアルゴリズムをタイプ２とします。
</p>
<p>
　タイプ１、
タイプ２それぞれに周波数間引き(DIF)と時間間引き(DIT)のアルゴリズムがあります。
すなわち、Stockham のアルゴリズムは最低でも４種類あることになります。
</p>
<div style="text-align:center;max-width:900px">
タイプ１-DIF Stockham アルゴリズム
</div>
<pre style="border:1px solid gray;padding:4px;max-width:900px;overflow:auto">
#include &lt;complex&gt;
#include &lt;cmath&gt;

typedef std::complex&lt;double&gt; complex_t;

void fft0(int n, int s, bool eo, complex_t* x, complex_t* y)
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n == 1) { if (eo) for (int q = 0; q &lt; s; q++) y[q] = x[q]; }
    else {
        for (int p = 0; p &lt; m; p++) {
            const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
            for (int q = 0; q &lt; s; q++) {
                const complex_t a = x[q + s*(p + 0)];
                const complex_t b = x[q + s*(p + m)];
                y[q + s*(2*p + 0)] =  a + b;
                y[q + s*(2*p + 1)] = (a - b) * wp;
            }
        }
        fft0(n/2, 2*s, !eo, y, x);
    }
}

void fft(int n, complex_t* x)
{
    complex_t* y = new complex_t[n];
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] /= n;
}

void ifft(int n, complex_t* x)
{
    for (int p = 0; p &lt; n; p++) x[p] = conj(x[p]);
    complex_t* y = new complex_t[n];
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] = conj(x[k]);
}
</pre>
<br>

<div style="text-align:center;max-width:900px">
タイプ１-DIT Stockham アルゴリズム
</div>
<pre style="border:1px solid gray;padding:4px;max-width:900px;overflow:auto">
#include &lt;complex&gt;
#include &lt;cmath&gt;

typedef std::complex&lt;double&gt; complex_t;

void fft0(int n, int s, bool eo, complex_t* x, complex_t* y)
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n == 1) { if (eo) for (int q = 0; q &lt; s; q++) x[q] = y[q]; }
    else {
        fft0(n/2, 2*s, !eo, y, x);
        for (int p = 0; p &lt; m; p++) {
            const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
            for (int q = 0; q &lt; s; q++) {
                const complex_t a = y[q + s*(2*p + 0)];
                const complex_t b = y[q + s*(2*p + 1)] * wp;
                x[q + s*(p + 0)] = a + b;
                x[q + s*(p + m)] = a - b;
            }
        }
    }
}

void fft(int n, complex_t* x)
{
    complex_t* y = new complex_t[n];
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] /= n;
}

void ifft(int n, complex_t* x)
{
    for (int p = 0; p &lt; n; p++) x[p] = conj(x[p]);
    complex_t* y = new complex_t[n];
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] = conj(x[k]);
}
</pre>
<br>

<div style="text-align:center;max-width:900px">
タイプ２-DIF Stockham アルゴリズム
</div>
<pre style="border:1px solid gray;padding:4px;max-width:900px;overflow:auto">
#include &lt;complex&gt;
#include &lt;cmath&gt;

typedef std::complex&lt;double&gt; complex_t;

void fft0(int n, int s, bool eo, complex_t* x, complex_t* y)
{
    const int m = n/2;
    const double theta0 = M_PI/s;

    if (n == 1) { if (eo) for (int q = 0; q &lt; s; q++) x[q] = y[q]; }
    else {
        fft0(n/2, 2*s, !eo, y, x);
        for (int p = 0; p &lt; m; p++) {
            for (int q = 0; q &lt; s; q++) {
                const complex_t wq = complex_t(cos(q*theta0), -sin(q*theta0));
                const complex_t a = y[q + s*(2*p + 0)];
                const complex_t b = y[q + s*(2*p + 1)];
                x[q + s*(p + 0)] =  a + b;
                x[q + s*(p + m)] = (a - b)*wq;
            }
        }
    }
}

void fft(int n, complex_t* x)
{
    complex_t* y = new complex_t[n];
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] /= n;
}

void ifft(int n, complex_t* x)
{
    for (int p = 0; p &lt; n; p++) x[p] = conj(x[p]);
    complex_t* y = new complex_t[n];
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] = conj(x[k]);
}
</pre>
<br>

<div style="text-align:center;max-width:900px">
タイプ２-DIT Stockham アルゴリズム
</div>
<pre style="border:1px solid gray;padding:4px;max-width:900px;overflow:auto">
#include &lt;complex&gt;
#include &lt;cmath&gt;

typedef std::complex&lt;double&gt; complex_t;

void fft0(int n, int s, bool eo, complex_t* x, complex_t* y)
{
    const int m = n/2;
    const double theta0 = M_PI/s;

    if (n == 1) { if (eo) for (int q = 0; q &lt; s; q++) y[q] = x[q]; }
    else {
        for (int p = 0; p &lt; m; p++) {
            for (int q = 0; q &lt; s; q++) {
                const complex_t wq = complex_t(cos(q*theta0), -sin(q*theta0));
                const complex_t a = x[q + s*(p + 0)];
                const complex_t b = x[q + s*(p + m)] * wq;
                y[q + s*(2*p + 0)] = a + b;
                y[q + s*(2*p + 1)] = a - b;
            }
        }
        fft0(n/2, 2*s, !eo, y, x);
    }
}

void fft(int n, complex_t* x)
{
    complex_t* y = new complex_t[n];
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] /= n;
}

void ifft(int n, complex_t* x)
{
    for (int p = 0; p &lt; n; p++) x[p] = conj(x[p]);
    complex_t* y = new complex_t[n];
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] = conj(x[k]);
}
</pre>

<hr>
<b>Next:</b> <a HREF="optimize1.html">配列へアクセスをさらに減らす最適化</a>
<b>Up:</b> <a HREF="stockham.html">トップページ</a>
<b>Previous:</b> <a HREF="node7.html">ダウンロード</a>
</body>
</html>
