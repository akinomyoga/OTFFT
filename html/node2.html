<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="description" content="再帰版の Stockham FFT をループで書き換える">
<meta name="keywords" content="Stockham FFT,FFT,C++">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="stockham.css" type="text/css">
<link rel="next" href="node3.html">
<link rel="prev" href="node1.html">
<link rel="up" href="stockham.html">

<!--
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
-->
<script type="text/javascript" src="ga.js"></script>

<title>Stockham のアルゴリズムの完成</title>
</head>
<body>
<b>Next:</b> <a href="node3.html">４基底の Stockham FFT</a>
<b>Up:</b> <a href="stockham.html">トップページ</a>
<b>Previous:</b> <a href="node1.html">Stockham FFT 入門</a>
<b>Reference:</b> <a href="http://www.moon.sannet.ne.jp/okahisa/otfft-en/stockham2.html">English Page</a>
<hr>

<h1><a name="stockham-speedup"></a>
Stockham のアルゴリズムの完成
</h1>
<p>
　前章、<a href="node1.html#stockham-intro">セクション1</a>では
Cooley-Tukey のアルゴリズムから単純な変形で Stockham
のアルゴリズムを導きました。しかし、この再帰版のアルゴリズムは速度的に
Cooley-Tukey に有利な点はなく、そのままでは用いる価値はありません。
そこでこの章ではさらなる書き換えを行って通常の高速な Stockham
のアルゴリズムを導きましょう。
</p>
<p>
　関数型プログラミング言語の信者の方は、
何でも再帰で書くのが一番みたいに思っているかもしれませんが、
世の中再帰で書いてあると気がつかないこともあります。
再帰バリバリで書かれている
<a href="node1.html#list:selfsort1">リスト３</a>
のアルゴリズムを一部ループに書き換えてみましょう。
一つ一つフーリエ変換を呼び出していた部分をループで繰り返すようにします。
</p>
<p>
　<a href="node1.html#list:selfsort1">リスト３</a> の関数
<code>fft0(n,s,q,x,y), fft1(n,s,q,x,y)</code>
は
<code>x[q + s*p]</code> をアクセスして処理します。
<a href="node1.html#list:selfsort1">リスト３</a> は２分岐していく再帰ですので、
再帰の段数が進むと次のようになります。
</p>
<pre style="border:1px solid gray;padding:4px;max-width:900px;overflow:auto">
    再帰０段目
    fft0(8,1,0,x,y)
         x[p]

    再帰１段目
    fft1(4,2,0,x,y)                 fft1(4,2,1,x,y)
        x[2p+0]                         x[2p+1]

    再帰２段目
    fft0(2,4,0,x,y) fft0(2,4,2,x,y) fft0(2,4,1,x,y) fft0(2,4,3,x,y)
        x[4p+0]         x[4p+2]         x[4p+1]         x[4p+3]
</pre>
<div style="text-align:center;max-width:900px">
図１：<code>fft0</code> と <code>fft1</code> の再帰の様子
</div>
<p>
　系列長 8 を例にとり、関数の下にアクセスする要素を表示しています。
再帰２段目 <code>n = 2, s = 4</code> のときは <code>q = 0,2,1,3</code>
で処理することになります。
処理する順番が <code>0,1,2,3</code> ではないですが、
結局 <code>x[4p],x[4p+1],x[4p+2],x[4p+3]</code>
全てを処理することには変わりはありません。<code>n, s</code> は共通ですから
<code>q</code> をループ変数として <code>fft0(n,s,q,x,y)</code> を
<code>0</code> から <code>s-1</code> まで(つまり、3 まで)回してやれば、
再帰２段目とループが等価になることが分かります。
この事実に基づいて <a href="node1.html#list:selfsort1">リスト３</a>
の再帰の一部をループに書き換えてやると以下のようになります。
</p>
<a name="list:selfsort2"></a>
<div style="text-align:center;max-width:900px">
リスト５：再帰のループによる書き換え
</div>
<pre style="border:1px solid gray;padding:4px;max-width:900px;overflow:auto">
#include &lt;complex&gt;
#include &lt;cmath&gt;

typedef std::complex&lt;double&gt; complex_t;

void fft1(int n, int s, complex_t* x, complex_t* y);

void fft0(int n, int s, complex_t* x, complex_t* y)
// n : 系列長
// s : ストライド
// x : フーリエ変換する系列(入出力)
// y : 作業用配列
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n == 1) {}
    else {
        for (int q = 0; q &lt; s; q++) { // 再帰の代わりに導入したループ
            for (int p = 0; p &lt; m; p++) {
                const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
                const complex_t a = x[q + s*(p + 0)];
                const complex_t b = x[q + s*(p + m)];
                y[q + s*(2*p + 0)] =  a + b;
                y[q + s*(2*p + 1)] = (a - b) * wp;
            }
        }
        fft1(n/2, 2*s, y, x); // 再帰をループで束ねたので呼び出しは1つ
    }
}

void fft1(int n, int s, complex_t* x, complex_t* y)
// n : 系列長
// s : ストライド
// x : フーリエ変換する系列(入力)
// y : 作業用配列兼出力配列(出力)
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n == 1) { for (int q = 0; q &lt; s; q++) y[q] = x[q]; }
    else {
        for (int q = 0; q &lt; s; q++) { // 再帰の代わりに導入したループ
            for (int p = 0; p &lt; m; p++) {
                const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
                const complex_t a = x[q + s*(p + 0)];
                const complex_t b = x[q + s*(p + m)];
                y[q + s*(2*p + 0)] =  a + b;
                y[q + s*(2*p + 1)] = (a - b) * wp;
            }
        }
        fft0(n/2, 2*s, y, x); // 再帰をループで束ねたので呼び出しは1つ
    }
}

void fft(int n, complex_t* x) // フーリエ変換
// n : 系列長
// x : フーリエ変換する系列(入出力)
{
    complex_t* y = new complex_t[n]; // 並べ替え用作業配列の確保
    fft0(n, 1, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] /= n;
}

void ifft(int n, complex_t* x) // 逆フーリエ変換
// n : 系列長
// x : 逆フーリエ変換する系列(入出力)
{
    for (int p = 0; p &lt; n; p++) x[p] = conj(x[p]);
    complex_t* y = new complex_t[n]; // 並べ替え用作業配列の確保
    fft0(n, 1, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] = conj(x[k]);
}
</pre>
<p>
　どうでしょう。
２分岐していく再帰が分岐しない再帰になってかなりスッキリしましたね。
これでもう一段、再帰をループに書き換えられることが分かると思います。しかし、
重要な点はそこではありません。そう、勘の良い人はもう気がついたと思いますが、
変数 <code>p</code> のループと変数 <code>q</code> のループは入れ替え可能です。
実はこのループを入れ替えると決定的な速度の差が現れます。
</p>
<p>
　再帰版 Stockham のアルゴリズムが遅いのは、再帰の段数が深くなるとストライド
<code>s</code> が大きくなって、
配列を大きく飛び飛びにアクセスすることになるからです。
最近のコンピュータはこういうメモリのアクセスをすると速度が低下します。
いわゆるキャッシュに入り切らなくなると言うやつです。それでは、
ループを入れ替えてみましょう。次のようになります。
</p>
<a name="list:selfsort3"></a>
<div style="text-align:center;max-width:900px">
リスト６：ループを入れ替えた Stockham のアルゴリズム
</div>
<pre style="border:1px solid gray;padding:4px;max-width:900px;overflow:auto">
#include &lt;complex&gt;
#include &lt;cmath&gt;

typedef std::complex&lt;double&gt; complex_t;

void fft1(int n, int s, complex_t* x, complex_t* y);

void fft0(int n, int s, complex_t* x, complex_t* y)
// n : 系列長
// s : ストライド
// x : フーリエ変換する系列(入出力)
// y : 作業用配列
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n == 1) {}
    else {
        for (int p = 0; p &lt; m; p++) {
            const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
            for (int q = 0; q &lt; s; q++) {
                const complex_t a = x[q + s*(p + 0)];
                const complex_t b = x[q + s*(p + m)];
                y[q + s*(2*p + 0)] =  a + b;
                y[q + s*(2*p + 1)] = (a - b) * wp;
            }
        }
        fft1(n/2, 2*s, y, x);
    }
}

void fft1(int n, int s, complex_t* x, complex_t* y)
// n : 系列長
// s : ストライド
// x : フーリエ変換する系列(入力)
// y : 作業用配列兼出力配列(出力)
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n == 1) { for (int q = 0; q &lt; s; q++) y[q] = x[q]; }
    else {
        for (int p = 0; p &lt; m; p++) {
            const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
            for (int q = 0; q &lt; s; q++) {
                const complex_t a = x[q + s*(p + 0)];
                const complex_t b = x[q + s*(p + m)];
                y[q + s*(2*p + 0)] =  a + b;
                y[q + s*(2*p + 1)] = (a - b) * wp;
            }
        }
        fft0(n/2, 2*s, y, x);
    }
}

void fft(int n, complex_t* x) // フーリエ変換
// n : 系列長
// x : フーリエ変換する系列(入出力)
{
    complex_t* y = new complex_t[n];
    fft0(n, 1, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] /= n;
}

void ifft(int n, complex_t* x) // 逆フーリエ変換
// n : 系列長
// x : 逆フーリエ変換する系列(入出力)
{
    for (int p = 0; p &lt; n; p++) x[p] = conj(x[p]);
    complex_t* y = new complex_t[n];
    fft0(n, 1, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] = conj(x[k]);
}
</pre>
<p>
　するとあら不思議、配列へのアクセスがストライド 1 になってしまいました。
ついでに三角関数の取得も一つ外側のループに移動できて、
さらに効率が上がっています。
そう、これこそが一般に言われる Stockham のアルゴリズムなのです。
</p>
<p>
　さて、このままでも良いのですが、
相互再帰でほとんど同じことを２回書くのは嫌な感じですよね。
そこで今どちらの関数なのかを表すフラグ <code>eo</code>
を導入して通常の再帰に書き換えてみましょう。以下のようになります。
</p>
<a name="list:selfsort4"></a>
<div style="text-align:center;max-width:900px">
リスト７：完成版 Stockham のアルゴリズム
</div>
<pre style="border:1px solid gray;padding:4px;max-width:900px;overflow:auto">
#include &lt;complex&gt;
#include &lt;cmath&gt;

typedef std::complex&lt;double&gt; complex_t;

void fft0(int n, int s, bool eo, complex_t* x, complex_t* y)
// n  : 系列長
// s  : ストライド
// eo : eo == 0 か false なら x が出力、eo == 1 か true なら y が出力
// x  : フーリエ変換する入力系列(eo == 0 のとき出力)
// y  : 作業用配列(eo == 1 のとき出力)
{
    const int m = n/2;
    const double theta0 = 2*M_PI/n;

    if (n == 1) { if (eo) for (int q = 0; q &lt; s; q++) y[q] = x[q]; }
    else {
        for (int p = 0; p &lt; m; p++) {
            const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0));
            for (int q = 0; q &lt; s; q++) {
                const complex_t a = x[q + s*(p + 0)];
                const complex_t b = x[q + s*(p + m)];
                y[q + s*(2*p + 0)] =  a + b;
                y[q + s*(2*p + 1)] = (a - b) * wp;
            }
        }
        fft0(n/2, 2*s, !eo, y, x);
    }
}

void fft(int n, complex_t* x) // フーリエ変換
// n : 系列長
// x : フーリエ変換する系列(入出力)
{
    complex_t* y = new complex_t[n];
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] /= n;
}

void ifft(int n, complex_t* x) // 逆フーリエ変換
// n : 系列長
// x : 逆フーリエ変換する系列(入出力)
{
    for (int p = 0; p &lt; n; p++) x[p] = conj(x[p]);
    complex_t* y = new complex_t[n];
    fft0(n, 1, 0, x, y);
    delete[] y;
    for (int k = 0; k &lt; n; k++) x[k] = conj(x[k]);
}
</pre>
<p>
　次章、<a href="node3.html#stockham4">セクション3</a>で、
応用問題として4基底の Stockham のアルゴリズムを
Cooley-Tukey のアルゴリズムから導いてみましょう。
</p>

<hr>
<b>Next:</b> <a href="node3.html">４基底の Stockham FFT</a>
<b>Up:</b> <a href="stockham.html">トップページ</a>
<b>Previous:</b> <a href="node1.html">Stockham FFT 入門</a>
<b>Reference:</b> <a href="http://www.moon.sannet.ne.jp/okahisa/otfft-en/stockham2.html">English Page</a>
</body>
</html>
